# Towers of Hanoi Formula
#
# Demonstrates that molecule algebra solves the "million step workflow" problem.
# LLMs fail on long sequences because errors accumulate (99.9%^1000 ≈ 37% success).
# MAKER used voting to reduce error. We use mechanical structure instead.
#
# Key insight: The move sequence is deterministic. Only execution needs AI.
# And each step is trivial: "move disk X from peg Y to peg Z".
#
# For n disks: 2^n - 1 moves
# 20 disks = 1,048,575 moves (the "million step" problem)
#
# Currently hardcoded for 3 disks (7 moves) as proof of concept.
# For million-step version, need to implement range expansion in cook.

formula: towers-of-hanoi
version: 2
description: |
  AGENT EXECUTION PROTOCOL - Towers of Hanoi

  PURPOSE: This is a durability proof, not computation. Steps are pre-computed.
  Your job is to execute them mechanically, proving crash-recovery at scale.

  EXECUTION LOOP:
  1. Find current state: bd mol current <mol-id>
  2. Find the next ready (unblocked) step
  3. Close it: bd close <step-id>
  4. Repeat until no ready steps remain

  ON RESUME (after crash/restart/handoff):
  - Same as fresh start. The molecule IS the state.
  - Query `bd mol current <mol-id>`, continue from there.
  - No memory of previous session needed.

  DO:
  - Close steps as fast as possible (they're trivial mechanical moves)
  - Use `gt handoff` when context fills (proactive cycling)
  - Trust the pre-computed solution - every move is already correct

  DO NOT:
  - Try to solve Hanoi yourself - moves are already computed
  - Mark steps in_progress - just close them directly
  - Ask for permission - this is GUPP territory, just execute
  - Stop for human input - run autonomously until complete

  MONITORING:
  - Progress: Count closed children of the molecule
  - For mega-molecules: Use convoy dashboard when available
  - Completion: All steps closed = molecule complete

  This proves Gas Town can execute arbitrarily long workflows with
  nondeterministic idempotence - different sessions, same outcome.

vars:
  source_peg:
    default: "A"
    description: "Starting peg"
  target_peg:
    default: "C"
    description: "Target peg"
  auxiliary_peg:
    default: "B"
    description: "Helper peg"

# 3-disk solution: 7 moves (2^3 - 1)
steps:
  - id: setup
    title: "Verify initial state"
    description: "All 3 disks stacked on peg A. Largest on bottom."

  - id: move-1
    title: "Move disk 1: A → C"
    description: "Move the smallest disk from peg A to peg C."
    needs: [setup]

  - id: move-2
    title: "Move disk 2: A → B"
    description: "Move disk 2 from peg A to peg B."
    needs: [move-1]

  - id: move-3
    title: "Move disk 1: C → B"
    description: "Move disk 1 from peg C to peg B."
    needs: [move-2]

  - id: move-4
    title: "Move disk 3: A → C"
    description: "Move the largest disk from peg A to peg C."
    needs: [move-3]

  - id: move-5
    title: "Move disk 1: B → A"
    description: "Move disk 1 from peg B to peg A."
    needs: [move-4]

  - id: move-6
    title: "Move disk 2: B → C"
    description: "Move disk 2 from peg B to peg C."
    needs: [move-5]

  - id: move-7
    title: "Move disk 1: A → C"
    description: "Move disk 1 from peg A to peg C."
    needs: [move-6]

  - id: verify
    title: "Verify final state"
    description: "All 3 disks now on peg C. Tower intact, all moves were legal."
    needs: [move-7]
